"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-intersection-observer";
exports.ids = ["vendor-chunks/react-intersection-observer"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-intersection-observer/dist/index.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/react-intersection-observer/dist/index.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InView: () => (/* binding */ InView),\n/* harmony export */   defaultFallbackInView: () => (/* binding */ defaultFallbackInView),\n/* harmony export */   observe: () => (/* binding */ observe),\n/* harmony export */   useInView: () => (/* binding */ useInView),\n/* harmony export */   useOnInView: () => (/* binding */ useOnInView)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* __next_internal_client_entry_do_not_use__ InView,defaultFallbackInView,observe,useInView,useOnInView auto */ var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n// src/InView.tsx\n\n// src/observe.ts\nvar observerMap = /* @__PURE__ */ new Map();\nvar RootIds = /* @__PURE__ */ new WeakMap();\nvar rootId = 0;\nvar unsupportedValue;\nfunction defaultFallbackInView(inView) {\n    unsupportedValue = inView;\n}\nfunction getRootId(root) {\n    if (!root) return \"0\";\n    if (RootIds.has(root)) return RootIds.get(root);\n    rootId += 1;\n    RootIds.set(root, rootId.toString());\n    return RootIds.get(root);\n}\nfunction optionsToId(options) {\n    return Object.keys(options).sort().filter((key)=>options[key] !== void 0).map((key)=>{\n        return `${key}_${key === \"root\" ? getRootId(options.root) : options[key]}`;\n    }).toString();\n}\nfunction createObserver(options) {\n    const id = optionsToId(options);\n    let instance = observerMap.get(id);\n    if (!instance) {\n        const elements = /* @__PURE__ */ new Map();\n        let thresholds;\n        const observer = new IntersectionObserver((entries)=>{\n            entries.forEach((entry)=>{\n                var _a2;\n                const inView = entry.isIntersecting && thresholds.some((threshold)=>entry.intersectionRatio >= threshold);\n                if (options.trackVisibility && typeof entry.isVisible === \"undefined\") {\n                    entry.isVisible = inView;\n                }\n                (_a2 = elements.get(entry.target)) == null ? void 0 : _a2.forEach((callback)=>{\n                    callback(inView, entry);\n                });\n            });\n        }, options);\n        thresholds = observer.thresholds || (Array.isArray(options.threshold) ? options.threshold : [\n            options.threshold || 0\n        ]);\n        instance = {\n            id,\n            observer,\n            elements\n        };\n        observerMap.set(id, instance);\n    }\n    return instance;\n}\nfunction observe(element, callback, options = {}, fallbackInView = unsupportedValue) {\n    if (typeof window.IntersectionObserver === \"undefined\" && fallbackInView !== void 0) {\n        const bounds = element.getBoundingClientRect();\n        callback(fallbackInView, {\n            isIntersecting: fallbackInView,\n            target: element,\n            intersectionRatio: typeof options.threshold === \"number\" ? options.threshold : 0,\n            time: 0,\n            boundingClientRect: bounds,\n            intersectionRect: bounds,\n            rootBounds: bounds\n        });\n        return ()=>{};\n    }\n    const { id, observer, elements } = createObserver(options);\n    const callbacks = elements.get(element) || [];\n    if (!elements.has(element)) {\n        elements.set(element, callbacks);\n    }\n    callbacks.push(callback);\n    observer.observe(element);\n    return function unobserve() {\n        callbacks.splice(callbacks.indexOf(callback), 1);\n        if (callbacks.length === 0) {\n            elements.delete(element);\n            observer.unobserve(element);\n        }\n        if (elements.size === 0) {\n            observer.disconnect();\n            observerMap.delete(id);\n        }\n    };\n}\n// src/InView.tsx\nfunction isPlainChildren(props) {\n    return typeof props.children !== \"function\";\n}\nvar InView = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props){\n        super(props);\n        __publicField(this, \"node\", null);\n        __publicField(this, \"_unobserveCb\", null);\n        __publicField(this, \"lastInView\");\n        __publicField(this, \"handleNode\", (node)=>{\n            if (this.node) {\n                this.unobserve();\n                if (!node && !this.props.triggerOnce && !this.props.skip) {\n                    this.setState({\n                        inView: !!this.props.initialInView,\n                        entry: void 0\n                    });\n                    this.lastInView = this.props.initialInView;\n                }\n            }\n            this.node = node ? node : null;\n            this.observeNode();\n        });\n        __publicField(this, \"handleChange\", (inView, entry)=>{\n            const previousInView = this.lastInView;\n            this.lastInView = inView;\n            if (previousInView === void 0 && !inView) {\n                return;\n            }\n            if (inView && this.props.triggerOnce) {\n                this.unobserve();\n            }\n            if (!isPlainChildren(this.props)) {\n                this.setState({\n                    inView,\n                    entry\n                });\n            }\n            if (this.props.onChange) {\n                this.props.onChange(inView, entry);\n            }\n        });\n        this.state = {\n            inView: !!props.initialInView,\n            entry: void 0\n        };\n        this.lastInView = props.initialInView;\n    }\n    componentDidMount() {\n        this.unobserve();\n        this.observeNode();\n    }\n    componentDidUpdate(prevProps) {\n        if (prevProps.rootMargin !== this.props.rootMargin || prevProps.root !== this.props.root || prevProps.threshold !== this.props.threshold || prevProps.skip !== this.props.skip || prevProps.trackVisibility !== this.props.trackVisibility || prevProps.delay !== this.props.delay) {\n            this.unobserve();\n            this.observeNode();\n        }\n    }\n    componentWillUnmount() {\n        this.unobserve();\n    }\n    observeNode() {\n        if (!this.node || this.props.skip) return;\n        const { threshold, root, rootMargin, trackVisibility, delay, fallbackInView } = this.props;\n        if (this.lastInView === void 0) {\n            this.lastInView = this.props.initialInView;\n        }\n        this._unobserveCb = observe(this.node, this.handleChange, {\n            threshold,\n            root,\n            rootMargin,\n            // @ts-expect-error\n            trackVisibility,\n            delay\n        }, fallbackInView);\n    }\n    unobserve() {\n        if (this._unobserveCb) {\n            this._unobserveCb();\n            this._unobserveCb = null;\n        }\n    }\n    render() {\n        const { children } = this.props;\n        if (typeof children === \"function\") {\n            const { inView, entry } = this.state;\n            return children({\n                inView,\n                entry,\n                ref: this.handleNode\n            });\n        }\n        const { as, triggerOnce, threshold, root, rootMargin, onChange, skip, trackVisibility, delay, initialInView, fallbackInView, ...props } = this.props;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(as || \"div\", {\n            ref: this.handleNode,\n            ...props\n        }, children);\n    }\n};\n// src/useInView.tsx\n\nfunction useInView({ threshold, delay, trackVisibility, rootMargin, root, triggerOnce, skip, initialInView, fallbackInView, onChange } = {}) {\n    var _a2;\n    const [ref, setRef] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const callback = react__WEBPACK_IMPORTED_MODULE_0__.useRef(onChange);\n    const lastInViewRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(initialInView);\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        inView: !!initialInView,\n        entry: void 0\n    });\n    callback.current = onChange;\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (lastInViewRef.current === void 0) {\n            lastInViewRef.current = initialInView;\n        }\n        if (skip || !ref) return;\n        let unobserve;\n        unobserve = observe(ref, (inView, entry)=>{\n            const previousInView = lastInViewRef.current;\n            lastInViewRef.current = inView;\n            if (previousInView === void 0 && !inView) {\n                return;\n            }\n            setState({\n                inView,\n                entry\n            });\n            if (callback.current) callback.current(inView, entry);\n            if (entry.isIntersecting && triggerOnce && unobserve) {\n                unobserve();\n                unobserve = void 0;\n            }\n        }, {\n            root,\n            rootMargin,\n            threshold,\n            // @ts-expect-error\n            trackVisibility,\n            delay\n        }, fallbackInView);\n        return ()=>{\n            if (unobserve) {\n                unobserve();\n            }\n        };\n    }, // We break the rule here, because we aren't including the actual `threshold` variable\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        // If the threshold is an array, convert it to a string, so it won't change between renders.\n        Array.isArray(threshold) ? threshold.toString() : threshold,\n        ref,\n        root,\n        rootMargin,\n        triggerOnce,\n        skip,\n        trackVisibility,\n        fallbackInView,\n        delay\n    ]);\n    const entryTarget = (_a2 = state.entry) == null ? void 0 : _a2.target;\n    const previousEntryTarget = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n    if (!ref && entryTarget && !triggerOnce && !skip && previousEntryTarget.current !== entryTarget) {\n        previousEntryTarget.current = entryTarget;\n        setState({\n            inView: !!initialInView,\n            entry: void 0\n        });\n        lastInViewRef.current = initialInView;\n    }\n    const result = [\n        setRef,\n        state.inView,\n        state.entry\n    ];\n    result.ref = result[0];\n    result.inView = result[1];\n    result.entry = result[2];\n    return result;\n}\n// src/useOnInView.tsx\n\nvar _a, _b;\nvar useSyncEffect = (_b = (_a = react__WEBPACK_IMPORTED_MODULE_0__.useInsertionEffect) != null ? _a : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect) != null ? _b : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nvar useOnInView = (onIntersectionChange, { threshold, root, rootMargin, trackVisibility, delay, triggerOnce, skip } = {})=>{\n    const onIntersectionChangeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(onIntersectionChange);\n    const observedElementRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const observerCleanupRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n    const lastInViewRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n    useSyncEffect(()=>{\n        onIntersectionChangeRef.current = onIntersectionChange;\n    }, [\n        onIntersectionChange\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((element)=>{\n        const cleanupExisting = ()=>{\n            if (observerCleanupRef.current) {\n                const cleanup = observerCleanupRef.current;\n                observerCleanupRef.current = void 0;\n                cleanup();\n            }\n        };\n        if (element === observedElementRef.current) {\n            return observerCleanupRef.current;\n        }\n        if (!element || skip) {\n            cleanupExisting();\n            observedElementRef.current = null;\n            lastInViewRef.current = void 0;\n            return;\n        }\n        cleanupExisting();\n        observedElementRef.current = element;\n        let destroyed = false;\n        const destroyObserver = observe(element, (inView, entry)=>{\n            const previousInView = lastInViewRef.current;\n            lastInViewRef.current = inView;\n            if (previousInView === void 0 && !inView) {\n                return;\n            }\n            onIntersectionChangeRef.current(inView, entry);\n            if (triggerOnce && inView) {\n                stopObserving();\n            }\n        }, {\n            threshold,\n            root,\n            rootMargin,\n            trackVisibility,\n            delay\n        });\n        function stopObserving() {\n            if (destroyed) return;\n            destroyed = true;\n            destroyObserver();\n            observedElementRef.current = null;\n            observerCleanupRef.current = void 0;\n            lastInViewRef.current = void 0;\n        }\n        observerCleanupRef.current = stopObserving;\n        return observerCleanupRef.current;\n    }, [\n        Array.isArray(threshold) ? threshold.toString() : threshold,\n        root,\n        rootMargin,\n        trackVisibility,\n        delay,\n        triggerOnce,\n        skip\n    ]);\n};\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtaW50ZXJzZWN0aW9uLW9ic2VydmVyL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF1Qjs7QUNFdkIsSUFBTUMsY0FBYyxvQkFBSUM7QUFTeEIsSUFBTUMsVUFBK0Msb0JBQUlDO0FBQ3pELElBQUlDLFNBQVM7QUFFYixJQUFJQztBQVFHLFNBQVNDLHNCQUFzQkMsTUFBQTtJQUNwQ0YsbUJBQW1CRTtBQUNyQjtBQU1BLFNBQVNDLFVBQVVDLElBQUE7SUFDakIsSUFBSSxDQUFDQSxNQUFNLE9BQU87SUFDbEIsSUFBSVAsUUFBUVEsR0FBQSxDQUFJRCxPQUFPLE9BQU9QLFFBQVFTLEdBQUEsQ0FBSUY7SUFDMUNMLFVBQVU7SUFDVkYsUUFBUVUsR0FBQSxDQUFJSCxNQUFNTCxPQUFPUyxRQUFBO0lBQ3pCLE9BQU9YLFFBQVFTLEdBQUEsQ0FBSUY7QUFDckI7QUFPTyxTQUFTSyxZQUFZQyxPQUFBO0lBQzFCLE9BQU9DLE9BQU9DLElBQUEsQ0FBS0YsU0FDaEJHLElBQUEsR0FDQUMsTUFBQSxDQUNDLENBQUNDLE1BQVFMLE9BQUEsQ0FBUUssSUFBcUMsS0FBTSxRQUU3REMsR0FBQSxDQUFJLENBQUNEO1FBQ0osT0FBTyxHQUFHQSxJQUFHLEdBQ1hBLFFBQVEsU0FDSlosVUFBVU8sUUFBUU4sSUFBSSxJQUN0Qk0sT0FBQSxDQUFRSyxJQUNkO0lBQ0YsR0FDQ1AsUUFBQTtBQUNMO0FBRUEsU0FBU1MsZUFBZVAsT0FBQTtJQUV0QixNQUFNUSxLQUFLVCxZQUFZQztJQUN2QixJQUFJUyxXQUFXeEIsWUFBWVcsR0FBQSxDQUFJWTtJQUUvQixJQUFJLENBQUNDLFVBQVU7UUFFYixNQUFNQyxXQUFXLG9CQUFJeEI7UUFDckIsSUFBSXlCO1FBRUosTUFBTUMsV0FBVyxJQUFJQyxxQkFBcUIsQ0FBQ0M7WUFDekNBLFFBQVFDLE9BQUEsQ0FBUSxDQUFDQztnQkF0RXZCLElBQUFDO2dCQXlFUSxN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T0FBQSxDQUN0QjNGLFFBQ0F3QjtZQUVGLElBQUl1QyxlQUFlL0QsUUFBUTtnQkFDekIrRztZQUNGO1FBQ0YsR0FDQTtZQUNFbkY7WUFDQTFCO1lBQ0F5RTtZQUNBN0M7WUFDQThDO1FBQ0Y7UUFHRixTQUFTbUM7WUFHUCxJQUFJRixXQUFXO1lBQ2ZBLFlBQVk7WUFDWkM7WUFDQU4sbUJBQW1CYixPQUFBLEdBQVU7WUFDN0JjLG1CQUFtQmQsT0FBQSxHQUFVO1lBQzdCRCxjQUFjQyxPQUFBLEdBQVU7UUFDMUI7UUFFQWMsbUJBQW1CZCxPQUFBLEdBQVVvQjtRQUU3QixPQUFPTixtQkFBbUJkLE9BQUE7SUFDNUIsR0FDQTtRQUNFekQsTUFBTUMsT0FBQSxDQUFRUCxhQUFhQSxVQUFVdEIsUUFBQSxLQUFhc0I7UUFDbEQxQjtRQUNBeUU7UUFDQTdDO1FBQ0E4QztRQUNBYjtRQUNBQztLQUNGO0FBRUoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3ltaXNtby1wYXF1ZXRlcmlhLy4uL3NyYy9JblZpZXcudHN4P2FiYjciLCJ3ZWJwYWNrOi8vaG95bWlzbW8tcGFxdWV0ZXJpYS8uLi9zcmMvb2JzZXJ2ZS50cz8xZjAyIiwid2VicGFjazovL2hveW1pc21vLXBhcXVldGVyaWEvLi4vc3JjL3VzZUluVmlldy50c3g/NGMwZiIsIndlYnBhY2s6Ly9ob3ltaXNtby1wYXF1ZXRlcmlhLy4uL3NyYy91c2VPbkluVmlldy50c3g/YmFkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB0eXBlIHsgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJQcm9wcywgUGxhaW5DaGlsZHJlblByb3BzIH0gZnJvbSBcIi4vaW5kZXhcIjtcbmltcG9ydCB7IG9ic2VydmUgfSBmcm9tIFwiLi9vYnNlcnZlXCI7XG5cbnR5cGUgU3RhdGUgPSB7XG4gIGluVmlldzogYm9vbGVhbjtcbiAgZW50cnk/OiBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5O1xufTtcblxuZnVuY3Rpb24gaXNQbGFpbkNoaWxkcmVuKFxuICBwcm9wczogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJQcm9wcyB8IFBsYWluQ2hpbGRyZW5Qcm9wcyxcbik6IHByb3BzIGlzIFBsYWluQ2hpbGRyZW5Qcm9wcyB7XG4gIHJldHVybiB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gIT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLyoqXG4gIyMgUmVuZGVyIHByb3BzXG5cbiBUbyB1c2UgdGhlIGA8SW5WaWV3PmAgY29tcG9uZW50LCB5b3UgcGFzcyBpdCBhIGZ1bmN0aW9uLiBJdCB3aWxsIGJlIGNhbGxlZFxuIHdoZW5ldmVyIHRoZSBzdGF0ZSBjaGFuZ2VzLCB3aXRoIHRoZSBuZXcgdmFsdWUgb2YgYGluVmlld2AuIEluIGFkZGl0aW9uIHRvIHRoZVxuIGBpblZpZXdgIHByb3AsIGNoaWxkcmVuIGFsc28gcmVjZWl2ZSBhIGByZWZgIHRoYXQgc2hvdWxkIGJlIHNldCBvbiB0aGVcbiBjb250YWluaW5nIERPTSBlbGVtZW50LiBUaGlzIGlzIHRoZSBlbGVtZW50IHRoYXQgdGhlIEludGVyc2VjdGlvbk9ic2VydmVyIHdpbGxcbiBtb25pdG9yLlxuXG4gSWYgeW91IG5lZWQgaXQsIHlvdSBjYW4gYWxzbyBhY2Nlc3MgdGhlXG4gW2BJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ludGVyc2VjdGlvbk9ic2VydmVyRW50cnkpXG4gb24gYGVudHJ5YCwgZ2l2aW5nIHlvdSBhY2Nlc3MgdG8gYWxsIHRoZSBkZXRhaWxzIGFib3V0IHRoZSBjdXJyZW50IGludGVyc2VjdGlvblxuIHN0YXRlLlxuXG4gYGBganN4XG4gaW1wb3J0IHsgSW5WaWV3IH0gZnJvbSAncmVhY3QtaW50ZXJzZWN0aW9uLW9ic2VydmVyJztcblxuIGNvbnN0IENvbXBvbmVudCA9ICgpID0+IChcbiA8SW5WaWV3PlxuIHsoeyBpblZpZXcsIHJlZiwgZW50cnkgfSkgPT4gKFxuICAgICAgPGRpdiByZWY9e3JlZn0+XG4gICAgICAgIDxoMj57YEhlYWRlciBpbnNpZGUgdmlld3BvcnQgJHtpblZpZXd9LmB9PC9oMj5cbiAgICAgIDwvZGl2PlxuICAgICl9XG4gPC9JblZpZXc+XG4gKTtcblxuIGV4cG9ydCBkZWZhdWx0IENvbXBvbmVudDtcbiBgYGBcblxuICMjIFBsYWluIGNoaWxkcmVuXG5cbiBZb3UgY2FuIHBhc3MgYW55IGVsZW1lbnQgdG8gdGhlIGA8SW5WaWV3IC8+YCwgYW5kIGl0IHdpbGwgaGFuZGxlIGNyZWF0aW5nIHRoZVxuIHdyYXBwaW5nIERPTSBlbGVtZW50LiBBZGQgYSBoYW5kbGVyIHRvIHRoZSBgb25DaGFuZ2VgIG1ldGhvZCwgYW5kIGNvbnRyb2wgdGhlXG4gc3RhdGUgaW4geW91ciBvd24gY29tcG9uZW50LiBBbnkgZXh0cmEgcHJvcHMgeW91IGFkZCB0byBgPEluVmlldz5gIHdpbGwgYmVcbiBwYXNzZWQgdG8gdGhlIEhUTUwgZWxlbWVudCwgYWxsb3dpbmcgeW91IHNldCB0aGUgYGNsYXNzTmFtZWAsIGBzdHlsZWAsIGV0Yy5cblxuIGBgYGpzeFxuIGltcG9ydCB7IEluVmlldyB9IGZyb20gJ3JlYWN0LWludGVyc2VjdGlvbi1vYnNlcnZlcic7XG5cbiBjb25zdCBDb21wb25lbnQgPSAoKSA9PiAoXG4gPEluVmlldyBhcz1cImRpdlwiIG9uQ2hhbmdlPXsoaW5WaWV3LCBlbnRyeSkgPT4gY29uc29sZS5sb2coJ0ludmlldzonLCBpblZpZXcpfT5cbiA8aDI+UGxhaW4gY2hpbGRyZW4gYXJlIGFsd2F5cyByZW5kZXJlZC4gVXNlIG9uQ2hhbmdlIHRvIG1vbml0b3Igc3RhdGUuPC9oMj5cbiA8L0luVmlldz5cbiApO1xuXG4gZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50O1xuIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW5WaWV3IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFxuICBJbnRlcnNlY3Rpb25PYnNlcnZlclByb3BzIHwgUGxhaW5DaGlsZHJlblByb3BzLFxuICBTdGF0ZVxuPiB7XG4gIG5vZGU6IEVsZW1lbnQgfCBudWxsID0gbnVsbDtcbiAgX3Vub2JzZXJ2ZUNiOiAoKCkgPT4gdm9pZCkgfCBudWxsID0gbnVsbDtcbiAgbGFzdEluVmlldzogYm9vbGVhbiB8IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJQcm9wcyB8IFBsYWluQ2hpbGRyZW5Qcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaW5WaWV3OiAhIXByb3BzLmluaXRpYWxJblZpZXcsXG4gICAgICBlbnRyeTogdW5kZWZpbmVkLFxuICAgIH07XG4gICAgdGhpcy5sYXN0SW5WaWV3ID0gcHJvcHMuaW5pdGlhbEluVmlldztcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMudW5vYnNlcnZlKCk7XG4gICAgdGhpcy5vYnNlcnZlTm9kZSgpO1xuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wczogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJQcm9wcykge1xuICAgIC8vIElmIGEgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgb3B0aW9uIGNoYW5nZWQsIHJlaW5pdCB0aGUgb2JzZXJ2ZXJcbiAgICBpZiAoXG4gICAgICBwcmV2UHJvcHMucm9vdE1hcmdpbiAhPT0gdGhpcy5wcm9wcy5yb290TWFyZ2luIHx8XG4gICAgICBwcmV2UHJvcHMucm9vdCAhPT0gdGhpcy5wcm9wcy5yb290IHx8XG4gICAgICBwcmV2UHJvcHMudGhyZXNob2xkICE9PSB0aGlzLnByb3BzLnRocmVzaG9sZCB8fFxuICAgICAgcHJldlByb3BzLnNraXAgIT09IHRoaXMucHJvcHMuc2tpcCB8fFxuICAgICAgcHJldlByb3BzLnRyYWNrVmlzaWJpbGl0eSAhPT0gdGhpcy5wcm9wcy50cmFja1Zpc2liaWxpdHkgfHxcbiAgICAgIHByZXZQcm9wcy5kZWxheSAhPT0gdGhpcy5wcm9wcy5kZWxheVxuICAgICkge1xuICAgICAgdGhpcy51bm9ic2VydmUoKTtcbiAgICAgIHRoaXMub2JzZXJ2ZU5vZGUoKTtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnVub2JzZXJ2ZSgpO1xuICB9XG5cbiAgb2JzZXJ2ZU5vZGUoKSB7XG4gICAgaWYgKCF0aGlzLm5vZGUgfHwgdGhpcy5wcm9wcy5za2lwKSByZXR1cm47XG4gICAgY29uc3Qge1xuICAgICAgdGhyZXNob2xkLFxuICAgICAgcm9vdCxcbiAgICAgIHJvb3RNYXJnaW4sXG4gICAgICB0cmFja1Zpc2liaWxpdHksXG4gICAgICBkZWxheSxcbiAgICAgIGZhbGxiYWNrSW5WaWV3LFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKHRoaXMubGFzdEluVmlldyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmxhc3RJblZpZXcgPSB0aGlzLnByb3BzLmluaXRpYWxJblZpZXc7XG4gICAgfVxuICAgIHRoaXMuX3Vub2JzZXJ2ZUNiID0gb2JzZXJ2ZShcbiAgICAgIHRoaXMubm9kZSxcbiAgICAgIHRoaXMuaGFuZGxlQ2hhbmdlLFxuICAgICAge1xuICAgICAgICB0aHJlc2hvbGQsXG4gICAgICAgIHJvb3QsXG4gICAgICAgIHJvb3RNYXJnaW4sXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgdHJhY2tWaXNpYmlsaXR5LFxuICAgICAgICBkZWxheSxcbiAgICAgIH0sXG4gICAgICBmYWxsYmFja0luVmlldyxcbiAgICApO1xuICB9XG5cbiAgdW5vYnNlcnZlKCkge1xuICAgIGlmICh0aGlzLl91bm9ic2VydmVDYikge1xuICAgICAgdGhpcy5fdW5vYnNlcnZlQ2IoKTtcbiAgICAgIHRoaXMuX3Vub2JzZXJ2ZUNiID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVOb2RlID0gKG5vZGU/OiBFbGVtZW50IHwgbnVsbCkgPT4ge1xuICAgIGlmICh0aGlzLm5vZGUpIHtcbiAgICAgIC8vIENsZWFyIHRoZSBvbGQgb2JzZXJ2ZXIsIGJlZm9yZSB3ZSBzdGFydCBvYnNlcnZpbmcgYSBuZXcgZWxlbWVudFxuICAgICAgdGhpcy51bm9ic2VydmUoKTtcblxuICAgICAgaWYgKCFub2RlICYmICF0aGlzLnByb3BzLnRyaWdnZXJPbmNlICYmICF0aGlzLnByb3BzLnNraXApIHtcbiAgICAgICAgLy8gUmVzZXQgdGhlIHN0YXRlIGlmIHdlIGdldCBhIG5ldyBub2RlLCBhbmQgd2UgYXJlbid0IGlnbm9yaW5nIHVwZGF0ZXNcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGluVmlldzogISF0aGlzLnByb3BzLmluaXRpYWxJblZpZXcsIGVudHJ5OiB1bmRlZmluZWQgfSk7XG4gICAgICAgIHRoaXMubGFzdEluVmlldyA9IHRoaXMucHJvcHMuaW5pdGlhbEluVmlldztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm5vZGUgPSBub2RlID8gbm9kZSA6IG51bGw7XG4gICAgdGhpcy5vYnNlcnZlTm9kZSgpO1xuICB9O1xuXG4gIGhhbmRsZUNoYW5nZSA9IChpblZpZXc6IGJvb2xlYW4sIGVudHJ5OiBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5KSA9PiB7XG4gICAgY29uc3QgcHJldmlvdXNJblZpZXcgPSB0aGlzLmxhc3RJblZpZXc7XG4gICAgdGhpcy5sYXN0SW5WaWV3ID0gaW5WaWV3O1xuXG4gICAgLy8gSWdub3JlIHRoZSB2ZXJ5IGZpcnN0IGBmYWxzZWAgbm90aWZpY2F0aW9uIHNvIGNvbnN1bWVycyBvbmx5IGhlYXIgYWJvdXQgYWN0dWFsIHN0YXRlIGNoYW5nZXMuXG4gICAgaWYgKHByZXZpb3VzSW5WaWV3ID09PSB1bmRlZmluZWQgJiYgIWluVmlldykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpblZpZXcgJiYgdGhpcy5wcm9wcy50cmlnZ2VyT25jZSkge1xuICAgICAgLy8gSWYgYHRyaWdnZXJPbmNlYCBpcyB0cnVlLCB3ZSBzaG91bGQgc3RvcCBvYnNlcnZpbmcgdGhlIGVsZW1lbnQuXG4gICAgICB0aGlzLnVub2JzZXJ2ZSgpO1xuICAgIH1cbiAgICBpZiAoIWlzUGxhaW5DaGlsZHJlbih0aGlzLnByb3BzKSkge1xuICAgICAgLy8gU3RvcmUgdGhlIGN1cnJlbnQgU3RhdGUsIHNvIHdlIGNhbiBwYXNzIGl0IHRvIHRoZSBjaGlsZHJlbiBpbiB0aGUgbmV4dCByZW5kZXIgdXBkYXRlXG4gICAgICAvLyBUaGVyZSdzIG5vIHJlYXNvbiB0byB1cGRhdGUgdGhlIHN0YXRlIGZvciBwbGFpbiBjaGlsZHJlbiwgc2luY2UgaXQncyBub3QgdXNlZCBpbiB0aGUgcmVuZGVyaW5nLlxuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGluVmlldywgZW50cnkgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnByb3BzLm9uQ2hhbmdlKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciBpcyBhY3RpdmVseSBsaXN0ZW5pbmcgZm9yIG9uQ2hhbmdlLCBhbHdheXMgdHJpZ2dlciBpdFxuICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShpblZpZXcsIGVudHJ5KTtcbiAgICB9XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjb25zdCB7IGluVmlldywgZW50cnkgfSA9IHRoaXMuc3RhdGU7XG4gICAgICByZXR1cm4gY2hpbGRyZW4oeyBpblZpZXcsIGVudHJ5LCByZWY6IHRoaXMuaGFuZGxlTm9kZSB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBhcyxcbiAgICAgIHRyaWdnZXJPbmNlLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgcm9vdCxcbiAgICAgIHJvb3RNYXJnaW4sXG4gICAgICBvbkNoYW5nZSxcbiAgICAgIHNraXAsXG4gICAgICB0cmFja1Zpc2liaWxpdHksXG4gICAgICBkZWxheSxcbiAgICAgIGluaXRpYWxJblZpZXcsXG4gICAgICBmYWxsYmFja0luVmlldyxcbiAgICAgIC4uLnByb3BzXG4gICAgfSA9IHRoaXMucHJvcHMgYXMgUGxhaW5DaGlsZHJlblByb3BzO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBhcyB8fCBcImRpdlwiLFxuICAgICAgeyByZWY6IHRoaXMuaGFuZGxlTm9kZSwgLi4ucHJvcHMgfSxcbiAgICAgIGNoaWxkcmVuLFxuICAgICk7XG4gIH1cbn1cbiIsImltcG9ydCB0eXBlIHsgT2JzZXJ2ZXJJbnN0YW5jZUNhbGxiYWNrIH0gZnJvbSBcIi4vaW5kZXhcIjtcblxuY29uc3Qgb2JzZXJ2ZXJNYXAgPSBuZXcgTWFwPFxuICBzdHJpbmcsXG4gIHtcbiAgICBpZDogc3RyaW5nO1xuICAgIG9ic2VydmVyOiBJbnRlcnNlY3Rpb25PYnNlcnZlcjtcbiAgICBlbGVtZW50czogTWFwPEVsZW1lbnQsIEFycmF5PE9ic2VydmVySW5zdGFuY2VDYWxsYmFjaz4+O1xuICB9XG4+KCk7XG5cbmNvbnN0IFJvb3RJZHM6IFdlYWtNYXA8RWxlbWVudCB8IERvY3VtZW50LCBzdHJpbmc+ID0gbmV3IFdlYWtNYXAoKTtcbmxldCByb290SWQgPSAwO1xuXG5sZXQgdW5zdXBwb3J0ZWRWYWx1ZTogYm9vbGVhbiB8IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBXaGF0IHNob3VsZCBiZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBpZiB0aGUgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaXMgdW5zdXBwb3J0ZWQ/XG4gKiBJZGVhbGx5IHRoZSBwb2x5ZmlsbCBoYXMgYmVlbiBsb2FkZWQsIHlvdSBjYW4gaGF2ZSB0aGUgZm9sbG93aW5nIGhhcHBlbjpcbiAqIC0gYHVuZGVmaW5lZGA6IFRocm93IGFuIGVycm9yXG4gKiAtIGB0cnVlYCBvciBgZmFsc2VgOiBTZXQgdGhlIGBpblZpZXdgIHZhbHVlIHRvIHRoaXMgcmVnYXJkbGVzcyBvZiBpbnRlcnNlY3Rpb24gc3RhdGVcbiAqICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRGYWxsYmFja0luVmlldyhpblZpZXc6IGJvb2xlYW4gfCB1bmRlZmluZWQpIHtcbiAgdW5zdXBwb3J0ZWRWYWx1ZSA9IGluVmlldztcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHVuaXF1ZSBJRCBmb3IgdGhlIHJvb3QgZWxlbWVudFxuICogQHBhcmFtIHJvb3RcbiAqL1xuZnVuY3Rpb24gZ2V0Um9vdElkKHJvb3Q6IEludGVyc2VjdGlvbk9ic2VydmVySW5pdFtcInJvb3RcIl0pIHtcbiAgaWYgKCFyb290KSByZXR1cm4gXCIwXCI7XG4gIGlmIChSb290SWRzLmhhcyhyb290KSkgcmV0dXJuIFJvb3RJZHMuZ2V0KHJvb3QpO1xuICByb290SWQgKz0gMTtcbiAgUm9vdElkcy5zZXQocm9vdCwgcm9vdElkLnRvU3RyaW5nKCkpO1xuICByZXR1cm4gUm9vdElkcy5nZXQocm9vdCk7XG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgb3B0aW9ucyB0byBhIHN0cmluZyBJZCwgYmFzZWQgb24gdGhlIHZhbHVlcy5cbiAqIEVuc3VyZXMgd2UgY2FuIHJldXNlIHRoZSBzYW1lIG9ic2VydmVyIHdoZW4gb2JzZXJ2aW5nIGVsZW1lbnRzIHdpdGggdGhlIHNhbWUgb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvcHRpb25zVG9JZChvcHRpb25zOiBJbnRlcnNlY3Rpb25PYnNlcnZlckluaXQpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9wdGlvbnMpXG4gICAgLnNvcnQoKVxuICAgIC5maWx0ZXIoXG4gICAgICAoa2V5KSA9PiBvcHRpb25zW2tleSBhcyBrZXlvZiBJbnRlcnNlY3Rpb25PYnNlcnZlckluaXRdICE9PSB1bmRlZmluZWQsXG4gICAgKVxuICAgIC5tYXAoKGtleSkgPT4ge1xuICAgICAgcmV0dXJuIGAke2tleX1fJHtcbiAgICAgICAga2V5ID09PSBcInJvb3RcIlxuICAgICAgICAgID8gZ2V0Um9vdElkKG9wdGlvbnMucm9vdClcbiAgICAgICAgICA6IG9wdGlvbnNba2V5IGFzIGtleW9mIEludGVyc2VjdGlvbk9ic2VydmVySW5pdF1cbiAgICAgIH1gO1xuICAgIH0pXG4gICAgLnRvU3RyaW5nKCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmVyKG9wdGlvbnM6IEludGVyc2VjdGlvbk9ic2VydmVySW5pdCkge1xuICAvLyBDcmVhdGUgYSB1bmlxdWUgSUQgZm9yIHRoaXMgb2JzZXJ2ZXIgaW5zdGFuY2UsIGJhc2VkIG9uIHRoZSByb290LCByb290IG1hcmdpbiBhbmQgdGhyZXNob2xkLlxuICBjb25zdCBpZCA9IG9wdGlvbnNUb0lkKG9wdGlvbnMpO1xuICBsZXQgaW5zdGFuY2UgPSBvYnNlcnZlck1hcC5nZXQoaWQpO1xuXG4gIGlmICghaW5zdGFuY2UpIHtcbiAgICAvLyBDcmVhdGUgYSBtYXAgb2YgZWxlbWVudHMgdGhpcyBvYnNlcnZlciBpcyBnb2luZyB0byBvYnNlcnZlLiBFYWNoIGVsZW1lbnQgaGFzIGEgbGlzdCBvZiBjYWxsYmFja3MgdGhhdCBzaG91bGQgYmUgdHJpZ2dlcmVkLCBvbmNlIGl0IGNvbWVzIGludG8gdmlldy5cbiAgICBjb25zdCBlbGVtZW50cyA9IG5ldyBNYXA8RWxlbWVudCwgQXJyYXk8T2JzZXJ2ZXJJbnN0YW5jZUNhbGxiYWNrPj4oKTtcbiAgICBsZXQgdGhyZXNob2xkczogbnVtYmVyW10gfCByZWFkb25seSBudW1iZXJbXTtcblxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgIC8vIFdoaWxlIGl0IHdvdWxkIGJlIG5pY2UgaWYgeW91IGNvdWxkIGp1c3QgbG9vayBhdCBpc0ludGVyc2VjdGluZyB0byBkZXRlcm1pbmUgaWYgdGhlIGNvbXBvbmVudCBpcyBpbnNpZGUgdGhlIHZpZXdwb3J0LCBicm93c2VycyBjYW4ndCBhZ3JlZSBvbiBob3cgdG8gdXNlIGl0LlxuICAgICAgICAvLyAtRmlyZWZveCBpZ25vcmVzIGB0aHJlc2hvbGRgIHdoZW4gY29uc2lkZXJpbmcgYGlzSW50ZXJzZWN0aW5nYCwgc28gaXQgd2lsbCBuZXZlciBiZSBmYWxzZSBhZ2FpbiBpZiBgdGhyZXNob2xkYCBpcyA+IDBcbiAgICAgICAgY29uc3QgaW5WaWV3ID1cbiAgICAgICAgICBlbnRyeS5pc0ludGVyc2VjdGluZyAmJlxuICAgICAgICAgIHRocmVzaG9sZHMuc29tZSgodGhyZXNob2xkKSA9PiBlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA+PSB0aHJlc2hvbGQpO1xuXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igc3VwcG9ydCBJbnRlcnNlY3Rpb25PYnNlcnZlciB2MlxuICAgICAgICBpZiAob3B0aW9ucy50cmFja1Zpc2liaWxpdHkgJiYgdHlwZW9mIGVudHJ5LmlzVmlzaWJsZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIC8vIFRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBJbnRlcnNlY3Rpb24gT2JzZXJ2ZXIgdjIsIGZhbGxpbmcgYmFjayB0byB2MSBiZWhhdmlvci5cbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgZW50cnkuaXNWaXNpYmxlID0gaW5WaWV3O1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudHMuZ2V0KGVudHJ5LnRhcmdldCk/LmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2soaW5WaWV3LCBlbnRyeSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICAvLyBFbnN1cmUgd2UgaGF2ZSBhIHZhbGlkIHRocmVzaG9sZHMgYXJyYXkuIElmIG5vdCwgdXNlIHRoZSB0aHJlc2hvbGQgZnJvbSB0aGUgb3B0aW9uc1xuICAgIHRocmVzaG9sZHMgPVxuICAgICAgb2JzZXJ2ZXIudGhyZXNob2xkcyB8fFxuICAgICAgKEFycmF5LmlzQXJyYXkob3B0aW9ucy50aHJlc2hvbGQpXG4gICAgICAgID8gb3B0aW9ucy50aHJlc2hvbGRcbiAgICAgICAgOiBbb3B0aW9ucy50aHJlc2hvbGQgfHwgMF0pO1xuXG4gICAgaW5zdGFuY2UgPSB7XG4gICAgICBpZCxcbiAgICAgIG9ic2VydmVyLFxuICAgICAgZWxlbWVudHMsXG4gICAgfTtcblxuICAgIG9ic2VydmVyTWFwLnNldChpZCwgaW5zdGFuY2UpO1xuICB9XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSBlbGVtZW50IC0gRE9NIEVsZW1lbnQgdG8gb2JzZXJ2ZVxuICogQHBhcmFtIGNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gdHJpZ2dlciB3aGVuIGludGVyc2VjdGlvbiBzdGF0dXMgY2hhbmdlc1xuICogQHBhcmFtIG9wdGlvbnMgLSBJbnRlcnNlY3Rpb24gT2JzZXJ2ZXIgb3B0aW9uc1xuICogQHBhcmFtIGZhbGxiYWNrSW5WaWV3IC0gRmFsbGJhY2sgaW5WaWV3IHZhbHVlLlxuICogQHJldHVybiBGdW5jdGlvbiAtIENsZWFudXAgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgdHJpZ2dlcmVkIHRvIHVucmVnaXN0ZXIgdGhlIG9ic2VydmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZlKFxuICBlbGVtZW50OiBFbGVtZW50LFxuICBjYWxsYmFjazogT2JzZXJ2ZXJJbnN0YW5jZUNhbGxiYWNrLFxuICBvcHRpb25zOiBJbnRlcnNlY3Rpb25PYnNlcnZlckluaXQgPSB7fSxcbiAgZmFsbGJhY2tJblZpZXcgPSB1bnN1cHBvcnRlZFZhbHVlLFxuKSB7XG4gIGlmIChcbiAgICB0eXBlb2Ygd2luZG93LkludGVyc2VjdGlvbk9ic2VydmVyID09PSBcInVuZGVmaW5lZFwiICYmXG4gICAgZmFsbGJhY2tJblZpZXcgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBjb25zdCBib3VuZHMgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNhbGxiYWNrKGZhbGxiYWNrSW5WaWV3LCB7XG4gICAgICBpc0ludGVyc2VjdGluZzogZmFsbGJhY2tJblZpZXcsXG4gICAgICB0YXJnZXQ6IGVsZW1lbnQsXG4gICAgICBpbnRlcnNlY3Rpb25SYXRpbzpcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMudGhyZXNob2xkID09PSBcIm51bWJlclwiID8gb3B0aW9ucy50aHJlc2hvbGQgOiAwLFxuICAgICAgdGltZTogMCxcbiAgICAgIGJvdW5kaW5nQ2xpZW50UmVjdDogYm91bmRzLFxuICAgICAgaW50ZXJzZWN0aW9uUmVjdDogYm91bmRzLFxuICAgICAgcm9vdEJvdW5kczogYm91bmRzLFxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBOb3RoaW5nIHRvIGNsZWFudXBcbiAgICB9O1xuICB9XG4gIC8vIEFuIG9ic2VydmVyIHdpdGggdGhlIHNhbWUgb3B0aW9ucyBjYW4gYmUgcmV1c2VkLCBzbyBsZXRzIHVzZSB0aGlzIGZhY3RcbiAgY29uc3QgeyBpZCwgb2JzZXJ2ZXIsIGVsZW1lbnRzIH0gPSBjcmVhdGVPYnNlcnZlcihvcHRpb25zKTtcblxuICAvLyBSZWdpc3RlciB0aGUgY2FsbGJhY2sgbGlzdGVuZXIgZm9yIHRoaXMgZWxlbWVudFxuICBjb25zdCBjYWxsYmFja3MgPSBlbGVtZW50cy5nZXQoZWxlbWVudCkgfHwgW107XG4gIGlmICghZWxlbWVudHMuaGFzKGVsZW1lbnQpKSB7XG4gICAgZWxlbWVudHMuc2V0KGVsZW1lbnQsIGNhbGxiYWNrcyk7XG4gIH1cblxuICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVub2JzZXJ2ZSgpIHtcbiAgICAvLyBSZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gdGhlIGNhbGxiYWNrIGxpc3RcbiAgICBjYWxsYmFja3Muc3BsaWNlKGNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKSwgMSk7XG5cbiAgICBpZiAoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gTm8gbW9yZSBjYWxsYmFjayBleGlzdHMgZm9yIGVsZW1lbnQsIHNvIGRlc3Ryb3kgaXRcbiAgICAgIGVsZW1lbnRzLmRlbGV0ZShlbGVtZW50KTtcbiAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudHMuc2l6ZSA9PT0gMCkge1xuICAgICAgLy8gTm8gbW9yZSBlbGVtZW50cyBhcmUgYmVpbmcgb2JzZXJ2ZXIgYnkgdGhpcyBpbnN0YW5jZSwgc28gZGVzdHJveSBpdFxuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgb2JzZXJ2ZXJNYXAuZGVsZXRlKGlkKTtcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB0eXBlIHsgSW50ZXJzZWN0aW9uT3B0aW9ucywgSW5WaWV3SG9va1Jlc3BvbnNlIH0gZnJvbSBcIi4vaW5kZXhcIjtcbmltcG9ydCB7IG9ic2VydmUgfSBmcm9tIFwiLi9vYnNlcnZlXCI7XG5cbnR5cGUgU3RhdGUgPSB7XG4gIGluVmlldzogYm9vbGVhbjtcbiAgZW50cnk/OiBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5O1xufTtcblxuLyoqXG4gKiBSZWFjdCBIb29rcyBtYWtlIGl0IGVhc3kgdG8gbW9uaXRvciB0aGUgYGluVmlld2Agc3RhdGUgb2YgeW91ciBjb21wb25lbnRzLiBDYWxsXG4gKiB0aGUgYHVzZUluVmlld2AgaG9vayB3aXRoIHRoZSAob3B0aW9uYWwpIFtvcHRpb25zXSgjb3B0aW9ucykgeW91IG5lZWQuIEl0IHdpbGxcbiAqIHJldHVybiBhbiBhcnJheSBjb250YWluaW5nIGEgYHJlZmAsIHRoZSBgaW5WaWV3YCBzdGF0dXMgYW5kIHRoZSBjdXJyZW50XG4gKiBbYGVudHJ5YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ludGVyc2VjdGlvbk9ic2VydmVyRW50cnkpLlxuICogQXNzaWduIHRoZSBgcmVmYCB0byB0aGUgRE9NIGVsZW1lbnQgeW91IHdhbnQgdG8gbW9uaXRvciwgYW5kIHRoZSBob29rIHdpbGxcbiAqIHJlcG9ydCB0aGUgc3RhdHVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqIGltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG4gKiBpbXBvcnQgeyB1c2VJblZpZXcgfSBmcm9tICdyZWFjdC1pbnRlcnNlY3Rpb24tb2JzZXJ2ZXInO1xuICpcbiAqIGNvbnN0IENvbXBvbmVudCA9ICgpID0+IHtcbiAqICAgY29uc3QgeyByZWYsIGluVmlldywgZW50cnkgfSA9IHVzZUluVmlldyh7XG4gKiAgICAgICB0aHJlc2hvbGQ6IDAsXG4gKiAgIH0pO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8ZGl2IHJlZj17cmVmfT5cbiAqICAgICAgIDxoMj57YEhlYWRlciBpbnNpZGUgdmlld3BvcnQgJHtpblZpZXd9LmB9PC9oMj5cbiAqICAgICA8L2Rpdj5cbiAqICAgKTtcbiAqIH07XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUluVmlldyh7XG4gIHRocmVzaG9sZCxcbiAgZGVsYXksXG4gIHRyYWNrVmlzaWJpbGl0eSxcbiAgcm9vdE1hcmdpbixcbiAgcm9vdCxcbiAgdHJpZ2dlck9uY2UsXG4gIHNraXAsXG4gIGluaXRpYWxJblZpZXcsXG4gIGZhbGxiYWNrSW5WaWV3LFxuICBvbkNoYW5nZSxcbn06IEludGVyc2VjdGlvbk9wdGlvbnMgPSB7fSk6IEluVmlld0hvb2tSZXNwb25zZSB7XG4gIGNvbnN0IFtyZWYsIHNldFJlZl0gPSBSZWFjdC51c2VTdGF0ZTxFbGVtZW50IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGNhbGxiYWNrID0gUmVhY3QudXNlUmVmPEludGVyc2VjdGlvbk9wdGlvbnNbXCJvbkNoYW5nZVwiXT4ob25DaGFuZ2UpO1xuICBjb25zdCBsYXN0SW5WaWV3UmVmID0gUmVhY3QudXNlUmVmPGJvb2xlYW4gfCB1bmRlZmluZWQ+KGluaXRpYWxJblZpZXcpO1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlPFN0YXRlPih7XG4gICAgaW5WaWV3OiAhIWluaXRpYWxJblZpZXcsXG4gICAgZW50cnk6IHVuZGVmaW5lZCxcbiAgfSk7XG5cbiAgLy8gU3RvcmUgdGhlIG9uQ2hhbmdlIGNhbGxiYWNrIGluIGEgYHJlZmAsIHNvIHdlIGNhbiBhY2Nlc3MgdGhlIGxhdGVzdCBpbnN0YW5jZVxuICAvLyBpbnNpZGUgdGhlIGB1c2VFZmZlY3RgLCBidXQgd2l0aG91dCB0cmlnZ2VyaW5nIGEgcmVyZW5kZXIuXG4gIGNhbGxiYWNrLmN1cnJlbnQgPSBvbkNoYW5nZTtcblxuICAvLyBiaW9tZS1pZ25vcmUgbGludC9jb3JyZWN0bmVzcy91c2VFeGhhdXN0aXZlRGVwZW5kZW5jaWVzOiB0aHJlc2hvbGQgaXMgbm90IGNvcnJlY3RseSBkZXRlY3RlZCBhcyBhIGRlcGVuZGVuY3lcbiAgUmVhY3QudXNlRWZmZWN0KFxuICAgICgpID0+IHtcbiAgICAgIGlmIChsYXN0SW5WaWV3UmVmLmN1cnJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsYXN0SW5WaWV3UmVmLmN1cnJlbnQgPSBpbml0aWFsSW5WaWV3O1xuICAgICAgfVxuICAgICAgLy8gRW5zdXJlIHdlIGhhdmUgbm9kZSByZWYsIGFuZCB0aGF0IHdlIHNob3VsZG4ndCBza2lwIG9ic2VydmluZ1xuICAgICAgaWYgKHNraXAgfHwgIXJlZikgcmV0dXJuO1xuXG4gICAgICBsZXQgdW5vYnNlcnZlOiAoKCkgPT4gdm9pZCkgfCB1bmRlZmluZWQ7XG4gICAgICB1bm9ic2VydmUgPSBvYnNlcnZlKFxuICAgICAgICByZWYsXG4gICAgICAgIChpblZpZXcsIGVudHJ5KSA9PiB7XG4gICAgICAgICAgY29uc3QgcHJldmlvdXNJblZpZXcgPSBsYXN0SW5WaWV3UmVmLmN1cnJlbnQ7XG4gICAgICAgICAgbGFzdEluVmlld1JlZi5jdXJyZW50ID0gaW5WaWV3O1xuXG4gICAgICAgICAgLy8gSWdub3JlIHRoZSB2ZXJ5IGZpcnN0IGBmYWxzZWAgbm90aWZpY2F0aW9uIHNvIGNvbnN1bWVycyBvbmx5IGhlYXIgYWJvdXQgYWN0dWFsIHN0YXRlIGNoYW5nZXMuXG4gICAgICAgICAgaWYgKHByZXZpb3VzSW5WaWV3ID09PSB1bmRlZmluZWQgJiYgIWluVmlldykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICAgIGluVmlldyxcbiAgICAgICAgICAgIGVudHJ5LFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChjYWxsYmFjay5jdXJyZW50KSBjYWxsYmFjay5jdXJyZW50KGluVmlldywgZW50cnkpO1xuXG4gICAgICAgICAgaWYgKGVudHJ5LmlzSW50ZXJzZWN0aW5nICYmIHRyaWdnZXJPbmNlICYmIHVub2JzZXJ2ZSkge1xuICAgICAgICAgICAgLy8gSWYgaXQgc2hvdWxkIG9ubHkgdHJpZ2dlciBvbmNlLCB1bm9ic2VydmUgdGhlIGVsZW1lbnQgYWZ0ZXIgaXQncyBpblZpZXdcbiAgICAgICAgICAgIHVub2JzZXJ2ZSgpO1xuICAgICAgICAgICAgdW5vYnNlcnZlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgcm9vdE1hcmdpbixcbiAgICAgICAgICB0aHJlc2hvbGQsXG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIHRyYWNrVmlzaWJpbGl0eSxcbiAgICAgICAgICBkZWxheSxcbiAgICAgICAgfSxcbiAgICAgICAgZmFsbGJhY2tJblZpZXcsXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAodW5vYnNlcnZlKSB7XG4gICAgICAgICAgdW5vYnNlcnZlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICAvLyBXZSBicmVhayB0aGUgcnVsZSBoZXJlLCBiZWNhdXNlIHdlIGFyZW4ndCBpbmNsdWRpbmcgdGhlIGFjdHVhbCBgdGhyZXNob2xkYCB2YXJpYWJsZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbXG4gICAgICAvLyBJZiB0aGUgdGhyZXNob2xkIGlzIGFuIGFycmF5LCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLCBzbyBpdCB3b24ndCBjaGFuZ2UgYmV0d2VlbiByZW5kZXJzLlxuICAgICAgQXJyYXkuaXNBcnJheSh0aHJlc2hvbGQpID8gdGhyZXNob2xkLnRvU3RyaW5nKCkgOiB0aHJlc2hvbGQsXG4gICAgICByZWYsXG4gICAgICByb290LFxuICAgICAgcm9vdE1hcmdpbixcbiAgICAgIHRyaWdnZXJPbmNlLFxuICAgICAgc2tpcCxcbiAgICAgIHRyYWNrVmlzaWJpbGl0eSxcbiAgICAgIGZhbGxiYWNrSW5WaWV3LFxuICAgICAgZGVsYXksXG4gICAgXSxcbiAgKTtcblxuICBjb25zdCBlbnRyeVRhcmdldCA9IHN0YXRlLmVudHJ5Py50YXJnZXQ7XG4gIGNvbnN0IHByZXZpb3VzRW50cnlUYXJnZXQgPSBSZWFjdC51c2VSZWY8RWxlbWVudCB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcbiAgaWYgKFxuICAgICFyZWYgJiZcbiAgICBlbnRyeVRhcmdldCAmJlxuICAgICF0cmlnZ2VyT25jZSAmJlxuICAgICFza2lwICYmXG4gICAgcHJldmlvdXNFbnRyeVRhcmdldC5jdXJyZW50ICE9PSBlbnRyeVRhcmdldFxuICApIHtcbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgbm9kZSByZWYsIHRoZW4gcmVzZXQgdGhlIHN0YXRlICh1bmxlc3MgdGhlIGhvb2sgaXMgc2V0IHRvIG9ubHkgYHRyaWdnZXJPbmNlYCBvciBgc2tpcGApXG4gICAgLy8gVGhpcyBlbnN1cmVzIHdlIGNvcnJlY3RseSByZWZsZWN0IHRoZSBjdXJyZW50IHN0YXRlIC0gSWYgeW91IGFyZW4ndCBvYnNlcnZpbmcgYW55dGhpbmcsIHRoZW4gbm90aGluZyBpcyBpblZpZXdcbiAgICBwcmV2aW91c0VudHJ5VGFyZ2V0LmN1cnJlbnQgPSBlbnRyeVRhcmdldDtcbiAgICBzZXRTdGF0ZSh7XG4gICAgICBpblZpZXc6ICEhaW5pdGlhbEluVmlldyxcbiAgICAgIGVudHJ5OiB1bmRlZmluZWQsXG4gICAgfSk7XG4gICAgbGFzdEluVmlld1JlZi5jdXJyZW50ID0gaW5pdGlhbEluVmlldztcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IFtzZXRSZWYsIHN0YXRlLmluVmlldywgc3RhdGUuZW50cnldIGFzIEluVmlld0hvb2tSZXNwb25zZTtcblxuICAvLyBTdXBwb3J0IG9iamVjdCBkZXN0cnVjdHVyaW5nLCBieSBhZGRpbmcgdGhlIHNwZWNpZmljIHZhbHVlcy5cbiAgcmVzdWx0LnJlZiA9IHJlc3VsdFswXTtcbiAgcmVzdWx0LmluVmlldyA9IHJlc3VsdFsxXTtcbiAgcmVzdWx0LmVudHJ5ID0gcmVzdWx0WzJdO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB0eXBlIHtcbiAgSW50ZXJzZWN0aW9uQ2hhbmdlRWZmZWN0LFxuICBJbnRlcnNlY3Rpb25FZmZlY3RPcHRpb25zLFxufSBmcm9tIFwiLi9pbmRleFwiO1xuaW1wb3J0IHsgb2JzZXJ2ZSB9IGZyb20gXCIuL29ic2VydmVcIjtcblxuY29uc3QgdXNlU3luY0VmZmVjdCA9XG4gIChcbiAgICBSZWFjdCBhcyB0eXBlb2YgUmVhY3QgJiB7XG4gICAgICB1c2VJbnNlcnRpb25FZmZlY3Q/OiB0eXBlb2YgUmVhY3QudXNlRWZmZWN0O1xuICAgIH1cbiAgKS51c2VJbnNlcnRpb25FZmZlY3QgPz9cbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0ID8/XG4gIFJlYWN0LnVzZUVmZmVjdDtcblxuLyoqXG4gKiBSZWFjdCBIb29rcyBtYWtlIGl0IGVhc3kgdG8gbW9uaXRvciB3aGVuIGVsZW1lbnRzIGNvbWUgaW50byBhbmQgbGVhdmUgdmlldy4gQ2FsbFxuICogdGhlIGB1c2VPbkluVmlld2AgaG9vayB3aXRoIHlvdXIgY2FsbGJhY2sgYW5kIChvcHRpb25hbCkgW29wdGlvbnNdKCNvcHRpb25zKS5cbiAqIEl0IHdpbGwgcmV0dXJuIGEgcmVmIGNhbGxiYWNrIHRoYXQgeW91IGNhbiBhc3NpZ24gdG8gdGhlIERPTSBlbGVtZW50IHlvdSB3YW50IHRvIG1vbml0b3IuXG4gKiBXaGVuIHRoZSBlbGVtZW50IGVudGVycyBvciBsZWF2ZXMgdGhlIHZpZXdwb3J0LCB5b3VyIGNhbGxiYWNrIHdpbGwgYmUgdHJpZ2dlcmVkLlxuICpcbiAqIFRoaXMgaG9vayB0cmlnZ2VycyBubyByZS1yZW5kZXJzLCBhbmQgaXMgdXNlZnVsIGZvciBwZXJmb3JtYW5jZS1jcml0aWNhbCB1c2UtY2FzZXMgb3JcbiAqIHdoZW4geW91IG5lZWQgdG8gdHJpZ2dlciByZW5kZXIgaW5kZXBlbmRlbnQgc2lkZSBlZmZlY3RzIGxpa2UgdHJhY2tpbmcgb3IgbG9nZ2luZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKiBpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuICogaW1wb3J0IHsgdXNlT25JblZpZXcgfSBmcm9tICdyZWFjdC1pbnRlcnNlY3Rpb24tb2JzZXJ2ZXInO1xuICpcbiAqIGNvbnN0IENvbXBvbmVudCA9ICgpID0+IHtcbiAqICAgY29uc3QgaW5WaWV3UmVmID0gdXNlT25JblZpZXcoKGluVmlldywgZW50cnkpID0+IHtcbiAqICAgICBpZiAoaW5WaWV3KSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhcIkVsZW1lbnQgaXMgaW4gdmlld1wiLCBlbnRyeS50YXJnZXQpO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhcIkVsZW1lbnQgbGVmdCB2aWV3XCIsIGVudHJ5LnRhcmdldCk7XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGRpdiByZWY9e2luVmlld1JlZn0+XG4gKiAgICAgICA8aDI+VGhpcyBlbGVtZW50IGlzIGJlaW5nIG1vbml0b3JlZDwvaDI+XG4gKiAgICAgPC9kaXY+XG4gKiAgICk7XG4gKiB9O1xuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCB1c2VPbkluVmlldyA9IDxURWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KFxuICBvbkludGVyc2VjdGlvbkNoYW5nZTogSW50ZXJzZWN0aW9uQ2hhbmdlRWZmZWN0PFRFbGVtZW50PixcbiAge1xuICAgIHRocmVzaG9sZCxcbiAgICByb290LFxuICAgIHJvb3RNYXJnaW4sXG4gICAgdHJhY2tWaXNpYmlsaXR5LFxuICAgIGRlbGF5LFxuICAgIHRyaWdnZXJPbmNlLFxuICAgIHNraXAsXG4gIH06IEludGVyc2VjdGlvbkVmZmVjdE9wdGlvbnMgPSB7fSxcbikgPT4ge1xuICBjb25zdCBvbkludGVyc2VjdGlvbkNoYW5nZVJlZiA9IFJlYWN0LnVzZVJlZihvbkludGVyc2VjdGlvbkNoYW5nZSk7XG4gIGNvbnN0IG9ic2VydmVkRWxlbWVudFJlZiA9IFJlYWN0LnVzZVJlZjxURWxlbWVudCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBvYnNlcnZlckNsZWFudXBSZWYgPSBSZWFjdC51c2VSZWY8KCgpID0+IHZvaWQpIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuICBjb25zdCBsYXN0SW5WaWV3UmVmID0gUmVhY3QudXNlUmVmPGJvb2xlYW4gfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XG5cbiAgdXNlU3luY0VmZmVjdCgoKSA9PiB7XG4gICAgb25JbnRlcnNlY3Rpb25DaGFuZ2VSZWYuY3VycmVudCA9IG9uSW50ZXJzZWN0aW9uQ2hhbmdlO1xuICB9LCBbb25JbnRlcnNlY3Rpb25DaGFuZ2VdKTtcblxuICAvLyBiaW9tZS1pZ25vcmUgbGludC9jb3JyZWN0bmVzcy91c2VFeGhhdXN0aXZlRGVwZW5kZW5jaWVzOiBUaHJlc2hvbGQgYXJyYXlzIGFyZSBub3JtYWxpemVkIGluc2lkZSB0aGUgY2FsbGJhY2tcbiAgcmV0dXJuIFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIChlbGVtZW50OiBURWxlbWVudCB8IHVuZGVmaW5lZCB8IG51bGwpID0+IHtcbiAgICAgIC8vIFJlYWN0IDwxOSBuZXZlciBjYWxscyByZWYgY2FsbGJhY2tzIHdpdGggYG51bGxgIGR1cmluZyB1bm1vdW50LCBzbyB3ZVxuICAgICAgLy8gZWFnZXJseSB0ZWFyIGRvd24gZXhpc3Rpbmcgb2JzZXJ2ZXJzIG1hbnVhbGx5IHdoZW5ldmVyIHRoZSB0YXJnZXQgY2hhbmdlcy5cbiAgICAgIGNvbnN0IGNsZWFudXBFeGlzdGluZyA9ICgpID0+IHtcbiAgICAgICAgaWYgKG9ic2VydmVyQ2xlYW51cFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgY29uc3QgY2xlYW51cCA9IG9ic2VydmVyQ2xlYW51cFJlZi5jdXJyZW50O1xuICAgICAgICAgIG9ic2VydmVyQ2xlYW51cFJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKGVsZW1lbnQgPT09IG9ic2VydmVkRWxlbWVudFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZlckNsZWFudXBSZWYuY3VycmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFlbGVtZW50IHx8IHNraXApIHtcbiAgICAgICAgY2xlYW51cEV4aXN0aW5nKCk7XG4gICAgICAgIG9ic2VydmVkRWxlbWVudFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgbGFzdEluVmlld1JlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNsZWFudXBFeGlzdGluZygpO1xuXG4gICAgICBvYnNlcnZlZEVsZW1lbnRSZWYuY3VycmVudCA9IGVsZW1lbnQ7XG4gICAgICBsZXQgZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgICAgIGNvbnN0IGRlc3Ryb3lPYnNlcnZlciA9IG9ic2VydmUoXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIChpblZpZXcsIGVudHJ5KSA9PiB7XG4gICAgICAgICAgY29uc3QgcHJldmlvdXNJblZpZXcgPSBsYXN0SW5WaWV3UmVmLmN1cnJlbnQ7XG4gICAgICAgICAgbGFzdEluVmlld1JlZi5jdXJyZW50ID0gaW5WaWV3O1xuXG4gICAgICAgICAgLy8gSWdub3JlIHRoZSB2ZXJ5IGZpcnN0IGBmYWxzZWAgbm90aWZpY2F0aW9uIHNvIGNvbnN1bWVycyBvbmx5IGhlYXIgYWJvdXQgYWN0dWFsIHN0YXRlIGNoYW5nZXMuXG4gICAgICAgICAgaWYgKHByZXZpb3VzSW5WaWV3ID09PSB1bmRlZmluZWQgJiYgIWluVmlldykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9uSW50ZXJzZWN0aW9uQ2hhbmdlUmVmLmN1cnJlbnQoXG4gICAgICAgICAgICBpblZpZXcsXG4gICAgICAgICAgICBlbnRyeSBhcyBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5ICYgeyB0YXJnZXQ6IFRFbGVtZW50IH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAodHJpZ2dlck9uY2UgJiYgaW5WaWV3KSB7XG4gICAgICAgICAgICBzdG9wT2JzZXJ2aW5nKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdGhyZXNob2xkLFxuICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgcm9vdE1hcmdpbixcbiAgICAgICAgICB0cmFja1Zpc2liaWxpdHksXG4gICAgICAgICAgZGVsYXksXG4gICAgICAgIH0gYXMgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0LFxuICAgICAgKTtcblxuICAgICAgZnVuY3Rpb24gc3RvcE9ic2VydmluZygpIHtcbiAgICAgICAgLy8gQ2VudHJhbGl6ZWQgdGVhcmRvd24gc28gYm90aCBtYW51YWwgZGVzdHJveXMgYW5kIFJlYWN0IHJlZiB1cGRhdGVzIHNoYXJlXG4gICAgICAgIC8vIHRoZSBzYW1lIGNsZWFudXAgcGF0aCAobmVlZGVkIGZvciBSZWFjdCB2ZXJzaW9ucyB0aGF0IG5ldmVyIGNhbGwgdGhlIHJlZiB3aXRoIGBudWxsYCkuXG4gICAgICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICAgICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgZGVzdHJveU9ic2VydmVyKCk7XG4gICAgICAgIG9ic2VydmVkRWxlbWVudFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgb2JzZXJ2ZXJDbGVhbnVwUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxhc3RJblZpZXdSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgb2JzZXJ2ZXJDbGVhbnVwUmVmLmN1cnJlbnQgPSBzdG9wT2JzZXJ2aW5nO1xuXG4gICAgICByZXR1cm4gb2JzZXJ2ZXJDbGVhbnVwUmVmLmN1cnJlbnQ7XG4gICAgfSxcbiAgICBbXG4gICAgICBBcnJheS5pc0FycmF5KHRocmVzaG9sZCkgPyB0aHJlc2hvbGQudG9TdHJpbmcoKSA6IHRocmVzaG9sZCxcbiAgICAgIHJvb3QsXG4gICAgICByb290TWFyZ2luLFxuICAgICAgdHJhY2tWaXNpYmlsaXR5LFxuICAgICAgZGVsYXksXG4gICAgICB0cmlnZ2VyT25jZSxcbiAgICAgIHNraXAsXG4gICAgXSxcbiAgKTtcbn07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJvYnNlcnZlck1hcCIsIk1hcCIsIlJvb3RJZHMiLCJXZWFrTWFwIiwicm9vdElkIiwidW5zdXBwb3J0ZWRWYWx1ZSIsImRlZmF1bHRGYWxsYmFja0luVmlldyIsImluVmlldyIsImdldFJvb3RJZCIsInJvb3QiLCJoYXMiLCJnZXQiLCJzZXQiLCJ0b1N0cmluZyIsIm9wdGlvbnNUb0lkIiwib3B0aW9ucyIsIk9iamVjdCIsImtleXMiLCJzb3J0IiwiZmlsdGVyIiwia2V5IiwibWFwIiwiY3JlYXRlT2JzZXJ2ZXIiLCJpZCIsImluc3RhbmNlIiwiZWxlbWVudHMiLCJ0aHJlc2hvbGRzIiwib2JzZXJ2ZXIiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsImVudHJpZXMiLCJmb3JFYWNoIiwiZW50cnkiLCJfYSIsImlzSW50ZXJzZWN0aW5nIiwic29tZSIsInRocmVzaG9sZCIsImludGVyc2VjdGlvblJhdGlvIiwidHJhY2tWaXNpYmlsaXR5IiwiaXNWaXNpYmxlIiwidGFyZ2V0IiwiY2FsbGJhY2siLCJBcnJheSIsImlzQXJyYXkiLCJvYnNlcnZlIiwiZWxlbWVudCIsImZhbGxiYWNrSW5WaWV3Iiwid2luZG93IiwiYm91bmRzIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidGltZSIsImJvdW5kaW5nQ2xpZW50UmVjdCIsImludGVyc2VjdGlvblJlY3QiLCJyb290Qm91bmRzIiwiY2FsbGJhY2tzIiwicHVzaCIsInVub2JzZXJ2ZSIsInNwbGljZSIsImluZGV4T2YiLCJsZW5ndGgiLCJkZWxldGUiLCJzaXplIiwiZGlzY29ubmVjdCIsImlzUGxhaW5DaGlsZHJlbiIsInByb3BzIiwiY2hpbGRyZW4iLCJJblZpZXciLCJDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsIl9fcHVibGljRmllbGQiLCJub2RlIiwidHJpZ2dlck9uY2UiLCJza2lwIiwic2V0U3RhdGUiLCJpbml0aWFsSW5WaWV3IiwibGFzdEluVmlldyIsIm9ic2VydmVOb2RlIiwicHJldmlvdXNJblZpZXciLCJvbkNoYW5nZSIsInN0YXRlIiwiY29tcG9uZW50RGlkTW91bnQiLCJjb21wb25lbnREaWRVcGRhdGUiLCJwcmV2UHJvcHMiLCJyb290TWFyZ2luIiwiZGVsYXkiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsIl91bm9ic2VydmVDYiIsImhhbmRsZUNoYW5nZSIsInJlbmRlciIsInJlZiIsImhhbmRsZU5vZGUiLCJhcyIsImNyZWF0ZUVsZW1lbnQiLCJ1c2VJblZpZXciLCJzZXRSZWYiLCJSZWFjdDIiLCJ1c2VTdGF0ZSIsInVzZVJlZiIsImxhc3RJblZpZXdSZWYiLCJjdXJyZW50IiwidXNlRWZmZWN0IiwiZW50cnlUYXJnZXQiLCJwcmV2aW91c0VudHJ5VGFyZ2V0IiwicmVzdWx0IiwiX2IiLCJ1c2VTeW5jRWZmZWN0IiwiUmVhY3QzIiwidXNlSW5zZXJ0aW9uRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlT25JblZpZXciLCJvbkludGVyc2VjdGlvbkNoYW5nZSIsIm9uSW50ZXJzZWN0aW9uQ2hhbmdlUmVmIiwib2JzZXJ2ZWRFbGVtZW50UmVmIiwib2JzZXJ2ZXJDbGVhbnVwUmVmIiwidXNlQ2FsbGJhY2siLCJjbGVhbnVwRXhpc3RpbmciLCJjbGVhbnVwIiwiZGVzdHJveWVkIiwiZGVzdHJveU9ic2VydmVyIiwic3RvcE9ic2VydmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-intersection-observer/dist/index.mjs\n");

/***/ })

};
;